---
title: "R Notebook"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
  word_document: default
---

## Математическое моделирование

### Практика 7

### Нелинейные модели      

В практических примерах ниже показано как:   

* оценивать полиномиальную регрессию;    
* аппроксимировать нелинейные модели ступенчатыми функциями;   
* строить сплайны;    
* работать с локальной регрессией;    
* строить обобщённые линейные модели (GAM).   

*Модели*: полиномиальная регрессия, полиномиальная логистическая регрессия, ступенчатая модель, обобщённая линейная модель.   
*Данные*: `Wage {ISLR}`   

Подробные комментарии к коду лабораторных см. в [1], глава 7.   

```{r setup, warning = F, message = F}
library('ISLR')              # набор данных Auto
library('splines')           # сплайны
library('gam')               # обобщённые аддитивные модели
library('akima')             # график двумерной плоскости
library('ggplot2')           # красивые графики

my.seed <- 1

```

Работаем с набором данных по зарплатам 3000 работников-мужчин среднеатлантического региона `Wage`. Присоединяем его к пространству имён функцией `attach()`, и дальше обращаемся напрямую к столбцам таблицы.    

```{r}
attach(Wage)
```

Работаем со столбцами:    
* `wage` -- заработная плата работника до уплаты налогов;   
* `age` -- возраст работника в годах.   


## Полиномиальная регрессия

### Зависимость зарплаты от возраста   

Судя по графику ниже, ззаимосвязь заработной платы и возраста нелинейна. Наблюдается также группа наблюдений с высоким значением `wage`, граница проходит примерно на уровне 250.     

```{r, fig.height = 5, fig.width = 5}
gp <- ggplot(data = Wage, aes(x = age, y = wage))
gp <- gp + geom_point() + geom_abline(slope = 0, intercept = 250, col = 'red')
gp
```

Подгоняем полином четвёртой степени для зависимости заработной платы от возраста.    

```{r}
fit <- lm(wage ~ poly(age, 4), data = Wage)
round(coef(summary(fit)), 2)
```

Функция `poly(age, 4)` создаёт таблицу с базисом ортогональных полиномов: линейные комбинации значений переменной age в степенях от 1 до 4.   

```{r}
round(head(poly(age, 4)), 3)

# можно получить сами значения age в заданных степенях
round(head(poly(age, 4, raw = T)), 3)

# на прогноз не повлияет, но оценки параметров изменяются
fit.2 <- lm(wage ~ poly(age, 4, raw = T), data = Wage)
round(coef(summary(fit.2)), 2)

# границы изменения переменной age
agelims <- range(age)

# значения age, для которых делаем прогноз (от min до max с шагом 1)
age.grid <- seq(from = agelims[1], to = agelims[2])

# рассчитать прогнозы и их стандартные ошибки
preds <- predict(fit, newdata = list(age = age.grid), se = T)

# границы доверительного интервала для заработной платы
se.bands <- cbind(lower.bound = preds$fit - 2*preds$se.fit,
                  upper.bound = preds$fit + 2*preds$se.fit)

# смотрим результат
round(head(se.bands), 2)
```

Рисуем левую панель графика со слайда 4 презентации (рис. 7.1 книги). Функция `matlines()` рисует грфик столбцов одной матрицы против столбцов другой.     

```{r, fig.height = 5, fig.width = 5}
# наблюдения
plot(age, wage, xlim = agelims, cex = 0.5, col = 'darkgrey')

# заголовок
title('Полином четвёртой степени')

# модель
lines(age.grid, preds$fit, lwd = 2, col = 'blue')

# доверительные интервалы прогноза
matlines(age.grid, se.bands, lwd = 1, col = 'blue', lty = 3)
```

Убедимся, что прогнозы по моделям с различными вызовами `poly()` совпадают.   

```{r}
# прогнозы по второму вызову модели
preds2 <- predict(fit.2, newdata = list(age = age.grid), se = T)

# максимальное расхождение между прогнозами по двум вариантам вызова модели
max(abs(preds$fit - preds2$fit))
```

Теперь подбираем степень полинома, сравнивая модели со степенями от 1 до 5 с помощью дисперсионного анализа (ANOVA).   

```{r}
fit.1 <- lm(wage ~ age, data = Wage)
fit.2 <- lm(wage ~ poly(age, 2), data = Wage)
fit.3 <- lm(wage ~ poly(age, 3), data = Wage)
fit.4 <- lm(wage ~ poly(age, 4), data = Wage)
fit.5 <- lm(wage ~ poly(age, 5), data = Wage)

round(anova(fit.1, fit.2, fit.3, fit.4, fit.5), 2)
```

Рассматриваются пять моделей, в которых степени полинома от `age` идут по возрастанию. В крайнем правом столбце таблице приводятся p-значения для проверки нулевой гипотезы: текущая модель не даёт статистически значимого сокращения RSS по сравнению с предыдущей моделью. Можно сделать вывод, что степени 3 достаточно, дальнейшее увеличение степени не даёт значимого улучшения качества модели.       


### Зависимость вероятности получать зарплату > 250 от возраста   

Теперь вернёмся к группе наблюдений с высоким `wage`. Рассмотрим зависимость вероятности того, что величина зарплаты больше 250, от возраста.     
Подгоняем логистическую регрессию и делаем прогнозы, для этого используем функцию для оценки обобщённой линейной модели `glm()` и указываем тип модели `binomial`:        

```{r}
fit <- glm(I(wage > 250) ~ poly(age, 4), data = Wage, family = 'binomial')

# прогнозы
preds <- predict(fit, newdata = list(age = age.grid), se = T)

# пересчитываем доверительные интервалы и прогнозы в исходные ЕИ
pfit <- exp(preds$fit) / (1 + exp(preds$fit))
se.bands.logit <- cbind(lower.bound = preds$fit - 2*preds$se.fit,
                        upper.bound = preds$fit + 2*preds$se.fit)
se.bands <- exp(se.bands.logit)/(1 + exp(se.bands.logit))

# результат - доверительный интервал для вероятности события 
#   "Заработная плата выше 250".   
round(head(se.bands), 3)
```

Достраиваем график с 4 слайда презентации (рис. 7.1 книги). Рисуем правую панель.      

```{r, fig.height = 5, fig.width = 5}
# сетка для графика (изображаем вероятности, поэтому интервал изменения y мал)
plot(age, I(wage > 250), xlim = agelims, type = 'n', ylim = c(0, 0.2),
     ylab = 'P(Wage > 250 | Age)')

# фактические наблюдения показываем засечками
points(jitter(age), I((wage > 250) / 5), cex = 0.5, pch = '|', col = 'darkgrey')

# модель
lines(age.grid, pfit, lwd = 2, col = 'blue')

# доверительные интервалы
matlines(age.grid, se.bands, lwd = 1, col = 'blue', lty = 3)

# заголовок
title('Полином четвёртой степени')
```


## Ступенчатые функции   

Для начала определим несколько интервалов, на каждом из которых будем моделировать зависимость `wage` от `age` своим средним уровнем.   

```{r}
# нарезаем предиктор age на 4 равных интервала
table(cut(age, 4))

# подгоняем линейную модель на интервалах
fit <- lm(wage ~ cut(age, 4), data = Wage)
round(coef(summary(fit)), 2)

# прогноз -- это средние по `wage` на каждом интервале
preds.cut <- predict(fit, newdata = list(age = age.grid), se = T)

# интервальный прогноз
se.bands.cut <- cbind(lower.bound = preds.cut$fit - 2*preds.cut$se.fit,
                      upper.bound = preds.cut$fit + 2*preds.cut$se.fit)
```

Воспроизведём график со слайда 7 презентации (рис. 7.2 книги).   

```{r, fig.height = 5, fig.width = 5}
# наблюдения
plot(age, wage, xlim = agelims, cex = 0.5, col = 'darkgrey')

# модель
lines(age.grid, preds.cut$fit, lwd = 2, col = 'darkgreen')

# доверительные интервалы прогноза
matlines(x = age.grid, y = se.bands.cut, lwd = 1, col = 'darkgreen', lty = 3)

# заголовок
title('Ступенчатая функция')
```

Правая часть графика, для вероятности того, что зарплата выше 250.   

```{r, fig.height = 5, fig.width = 5}
fit <- glm(I(wage > 250) ~ cut(age, 4), data = Wage, family = 'binomial')

# прогнозы
preds <- predict(fit, newdata = list(age = age.grid), se = T)

# пересчитываем доверительные интервалы и прогнозы в исходные ЕИ
pfit <- exp(preds$fit) / (1 + exp(preds$fit))
se.bands.logit <- cbind(lower.bound = preds$fit - 2*preds$se.fit,
                        upper.bound = preds$fit + 2*preds$se.fit)
se.bands <- exp(se.bands.logit)/(1 + exp(se.bands.logit))

# результат - доверительный интервал для вероятности события 
#   "Заработная плата выше 250".   
round(head(se.bands), 3)

# сетка для графика (изображаем вероятности, поэтому интервал изменения y мал)
plot(age, I(wage > 250), xlim = agelims, type = 'n', ylim = c(0, 0.2),
     ylab = 'P(Wage > 250 | Age)')

# фактические наблюдения показываем засечками
points(jitter(age), I((wage > 250) / 5), cex = 0.5, pch = '|', col = 'darkgrey')

# модель
lines(age.grid, pfit, lwd = 2, col = 'darkgreen')

# доверительные интервалы
matlines(age.grid, se.bands, lwd = 1, col = 'darkgreen', lty = 3)

# заголовок
title('Ступенчатая функция')
```



## Сплайны   

Построим кубический сплайн с тремя узлами.   

```{r}
# кубический сплайн с тремя узлами
fit <- lm(wage ~ bs(age, knots = c(25, 40, 60)), data = Wage)
# прогноз
preds.spl <- predict(fit, newdata = list(age = age.grid), se = T)
```

Теперь построим натуральный по трём узлам. Три узла это 6 степеней свободы. Если функции `bs()`, которая создаёт матрицу с базисом для полиномиального сплайна, передать только степени свободы, она распределит узлы равномерно. В данном случае это квартили распределения `age`.     

```{r}
# 3 узла -- 6 степеней свободы (столбцы матрицы)
dim(bs(age, knots = c(25, 40, 60)))
# если не указываем узлы явно...
dim(bs(age, df = 6))
#  они привязываются к квартилям
attr(bs(age, df = 6), 'knots')

# натуральный сплайн
fit2 <- lm(wage ~ ns(age, df = 4), data = Wage)
preds.spl2 <- predict(fit2, newdata = list(age = age.grid), se = T)
```


График сравнения кубического и натурального сплайнов.   

```{r, fig.height = 5, fig.width = 5}
par(mfrow = c(1, 1), mar = c(4.5, 4.5, 1, 8.5), oma = c(0, 0, 0, 0), xpd = T)

# наблюдения
plot(age, wage, col = 'grey')

# модель кубического сплайна
lines(age.grid, preds.spl$fit, lwd = 2)

# доверительный интервал
lines(age.grid, preds.spl$fit + 2*preds.spl$se, lty = 'dashed')
lines(age.grid, preds.spl$fit - 2*preds.spl$se, lty = 'dashed')

# натуральный сплайн
lines(age.grid, preds.spl2$fit, col = 'red', lwd = 2)

# легенда
legend("topright", inset = c(-0.7, 0),
       c('Кубический \n с 3 узлами', 'Натуральный'),
       lwd = rep(2, 2), col = c('black', 'red'))

# заголовок
title("Сплайны")

```

Построим график со слайда 20 (рисунок 7.8 книги).   

```{r, fig.height = 5, fig.width = 5}
par(mfrow = c(1, 1), mar = c(4.5, 4.5, 1, 1), oma = c(0, 0, 4, 0))

# наблюдения
plot(age, wage, xlim = agelims, cex = 0.5, col = 'darkgrey')

# заголовок
title('Сглаживающий сплайн')

# подгоняем модель с 16 степенями свободы
fit <- smooth.spline(age, wage, df = 16)

# подгоняем модель с подбором лямбды с помощью перекрёстной проверки
fit2 <- smooth.spline(age, wage, cv = T)
fit2$df

# рисуем модель
lines(fit, col = 'red', lwd = 2)
lines(fit2, col = 'blue', lwd = 2)
legend('topright', 
       c('16 df', '6.8 df'),
       col = c('red', 'blue'), lty = 1, lwd = 2, cex = 0.8)
```

## Локальная регрессия   

Строим график со слайда 24 (рис. 7.10).   

```{r, fig.height = 5, fig.width = 5}
plot(age, wage, xlim = agelims, cex = 0.5, col = 'darkgrey')

title('Локальная регрессия')

# подгоняем модель c окном 0.2
fit <- loess(wage ~ age, span = 0.2, data = Wage)

# подгоняем модель c окном 0.5
fit2 <- loess(wage ~ age, span = 0.5, data = Wage)

# рисум модели
lines(age.grid, predict(fit, data.frame(age = age.grid)),
      col = 'red', lwd = 2)
lines(age.grid, predict(fit2, data.frame(age = age.grid)),
      col = 'blue', lwd = 2)

# легенда
legend('topright', 
       c('s = 0.2', 's = 0.5'),
       col = c('red', 'blue'), lty = 1, lwd = 2, cex = 0.8)
```


## Обобщённые аддитивные модели (GAM) с непрерывным откликом  

Построим GAM на натуральных сплайнах степеней 4 (`year`), 5 (`age`) с категориальным предиктором `edication`.    

```{r}
# GAM на натуральных сплайнах
gam.ns <- gam(wage ~ ns(year, 4) + ns(age, 5) + education, data = Wage)
```

Также построим модель на сглаживающих сплайнах.   

```{r}
# GAM на сглаживающих сплайнах
gam.m3 <- gam(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```

График со слайда 28 (рис. 7.12).   

```{r, fig.height = 5, fig.width = 5}
par(mfrow = c(1, 3))
plot(gam.m3, se = T, col = 'blue')
par(mfrow = c(1, 1))
```

График со слайда 27 (рис. 7.11).   

```{r, fig.height = 5, fig.width = 5}
par(mfrow = c(1, 3))
plot(gam.ns, se = T, col = 'red')
par(mfrow = c(1, 1))
```

График функции от `year` похож на прямую. Сделаем ANOVA, чтобы понять, какая степень для `year` лучше.  

```{r}
gam.m1 <- gam(wage ~ s(age, 5) + education, data = Wage)          # без year
gam.m2 <- gam(wage ~ year + s(age, 5) + education, data = Wage)   # year^1

anova(gam.m1, gam.m2, gam.m3, test = 'F')
```

Третья модель статистически не лучше второй. Кроме того, один из параметров этой модели незначим.   

```{r}
# сводка по модели gam.m3
summary(gam.m3)
```

Работаем с моделью `gam.m2`.   

```{r}
# прогноз по обучающей выборке
preds <- predict(gam.m2, newdata = Wage)
```

Также можно использовать в GAM локальные регрессии.   

```{r, fig.height = 5, fig.width = 5, warning = F, message = F}
# GAM на локальных регрессиях
gam.lo <- gam(wage ~ s(year, df = 4) + lo(age, span = 0.7) + education, 
              data = Wage)

par(mfrow = c(1, 3))
plot(gam.lo, se = T, col = 'green')
par(mfrow = c(1, 1))

# модель со взаимодействием регрессоров year и age
gam.lo.i <- gam(wage ~ lo(year, age, span = 0.5) + education, data = Wage)
par(mfrow = c(1, 2))
plot(gam.lo.i)
par(mfrow = c(1, 1))
```


## Логистическая GAM  

Построим логистическую GAM для всероятности того, что `wage` превышает 250.   

```{r, fig.height = 5, fig.width = 5}
gam.lr <- gam(I(wage > 250) ~ year + s(age, df = 5) + education, 
              family = 'binomial', data = Wage)
par(mfrow = c(1, 3))
plot(gam.lr, se = T, col = 'green')

# уровни образования по группам разного достатка
table(education, I(wage > 250))
```

В категории с самым низким уровнем образования нет wage > 250, поэтому убираем её.   

```{r, fig.height = 5, fig.width = 5}
gam.lr.s <- gam(I(wage > 250) ~ year + s(age, df = 5) + education,
                family = 'binomial', data = Wage, 
                subset = (education != "1. < HS Grad"))
# график
par(mfrow = c(1, 3))
plot(gam.lr.s, se = T, col = 'green')
```

```{r}
detach(Wage)
```

## Упражнение 7   

Необходимо построить две модели:  
* зависимости непрерывного отклика от одного непрерывного предиктора;
* зависимости вероятности (логит) от одного непрерывного предиктора.   

Для каждой модели:   

**1** Указать смысл переменных модели, метод оценки и настроечный параметр (степень полинома, гиперпараметр $λ$, ширина окна $s$, число узлов – в зависимости от метода).   

**2** Подогнать модель на всех наблюдениях, меняя значение настроечного параметра.   

**3** Обосновать оптимальное значение настроечного параметра подходящим методом (кросс-валидация, ANOVA).   

**4** Сделать прогноз на обучающую выборку по лучшей модели: модельные значения и ошибки прогноза.   

**5** Построить график с фактическими наблюдениями, модельной кривой и 95% доверительными интервалами прогноза.   

В таблице ниже указаны набор данных, столбцы с переменными для модели и метод подгонки.    

**Как сдавать:** прислать на почту преподавателя ссылки:
* на html-отчёт с видимыми блоками кода (блоки кода с параметром echo = T), размещённый на [rpubs.com](rpubs.com).   
* на код, генерирующий отчёт, в репозитории на [github.com](github.com).
В текст отчёта включить постановку задачи и ответы на вопросы задания.  

## Варианты

<table border="1">
<tr>
<td><b>Номер варианта</b></td>
<td><b>Данные</b></td>
<td><b>Зависимая переменная</b></td>
<td><b>Объясняющая переменная</b></td>
<td><b>Вероятность для второй модели</b></td>
<td><b>Метод подгонки моделей</b></td>
</tr>

<tr>
<td>1</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`nox`</td>
<td>$P(crim>30)$</td>
<td>Полиномиальный сплайн</td>
</tr>

<tr>
<td>2</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`dis`</td>
<td>$P(crim>30)$</td>
<td>Сглаживающие сплайны</td>
</tr>

<tr>
<td>3</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`nox`</td>
<td>$P(crim>30)$</td>
<td>Локальная регрессия</td>
</tr>

<tr>
<td>4</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`dis`</td>
<td>$P(crim>30)$</td>
<td>Ступенчатая функция</td>
</tr>

<tr>
<td>5</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`nox`</td>
<td>$P(crim>30)$</td>
<td>Натуральный кубический сплайн</td>
</tr>

<tr>
<td>6</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`dis`</td>
<td>$P(crim>30)$</td>
<td>Полиномиальный сплайн</td>
</tr>

<tr>
<td>7</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`nox`</td>
<td>$P(crim>30)$</td>
<td>Сглаживающие сплайны</td>
</tr>

<tr>
<td>8</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`dis`</td>
<td>$P(crim>30)$</td>
<td>Локальная регрессия</td>
</tr>

<tr>
<td>9</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`nox`</td>
<td>$P(crim>30)$</td>
<td>Ступенчатая функция</td>
</tr>

<tr>
<td>10</td>
<td>`Boston {MASS}`</td>
<td>`crim`</td>
<td>`dis`</td>
<td>$P(crim>30)$</td>
<td>Натуральный кубический сплайн</td>
</tr>

</table>


*Источники*   

1. *Джеймс Г., Уиттон Д., Хасти Т., Тибширани Р.* Введение в статистическое обучение с примерами на языке R / пер. с англ. С.Э. Мастицкого. -- М.: ДМК Пресс, **2016** -- 450 с. Репозиторий с примерами к книге на русском языке: [https://github.com/ranalytics/islr-ru](https://github.com/ranalytics/islr-ru)    
